#+TITLE:   Sean's Emacs Configuration
#+AUTHOR:  Sean Duckett
#+EMAIL:   sduckett@gmail.com
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+HTML_HEAD: <link rel="stylesheet" href="http://dakrone.github.io/org.css" type="text/css" />
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content

* Foreward

  This is a work in progress, where I attempt to write a literate configuration
  file for Emacs and see how it affects my thinking of the system as a whole.
  Depending on what version of this work you are reading, there might be steps
  that don't work, broken code, and descriptions that are hard to follow. Please
  accept my apologies and inform me of any glaring omissions. If anything is
  gained in the process, I will consider it to have been a useful exercise.

  This file was last exported: {{{time(%Y-%m-%d %H:%M)}}}

* Introduction

  The idea of writing a literate configuration file was mentioned during
  a recent office-hours chat, but the benefits described were limited to
  one: looking good on Github. I'm not sure I believe it, so I decided
  to give it a try and see if I happen to notice any additional benefits.

  To get started, have a look at your `~/.emacs.d/init.el`. If you'd
  done any customizations there, move them to a file (perhaps
  `~/.emacs.d/custom-additions.el`) that you can load after we do some
  setup.

  Next, get a list of installed packages (`M-x package-list-packages RET`)
  and search for the set of "Installed" packages (`C-s installed RET`).
  Make a list of the packages you've installed, if any, and put them in
  `~/.emacs.d/packages.el`. (This might come in useful later.)

  Put the following in `~/.emacs.d/init.el`:

#+BEGIN_SRC
  ;; keep customized settings in their own file
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file)
    (load custom-file))

  ;; load the package management configuration
  (setq package-configuration
        (expand-file-name "packages.el"
                          user-emacs-directory))
  (when (file-exists-p package-configuration)
    (load package-configuration))

  ;; translate the literate configuration and load it.
  (require 'org)
  (org-babel-load-file
   (expand-file-name "settings.org"
                     user-emacs-directory))
#+END_SRC

  Next, put the following in `~/.emacs.d/packages.el`:

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (when (< emacs-major-version 24)
    ;; For important compatibility libraries like cl-lib
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/")))

  (add-to-list 'package-archives
               '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives
               '("melpa-stable" . "http://stable.melpa.org/packages/"))

  (defvar my-packages '(better-defaults paredit idle-highlight-mode ido-ubiquitous
                        find-file-in-project magit smex scpaste clojure-mode))

  (dolist (p my-packages)
    (when (not (package-installed-p p))
          (package-install p)))

  (package-initialize)
  (setq package-enable-at-startup nil)

#+END_SRC

  This is the platform from which the rest of the configuration is built. When
  you start Emacs next, it will be configured by some Emacs Lisp that is
  generated from this org-mode file.

* Configuration
** Packages that need to be installed
This is code that installs packages before any config is loaded, since a lot of
things add hooks that don't work if packages aren't installed.

#+BEGIN_SRC emacs-lisp
  (defvar smd/install-packages
    '(
      ;; package management
      use-package

      ;; misc
      gist

      ;; for auto-complete
      fuzzy popup company

      ;; editing utilities
      expand-region smex ag ;;undo-tree iedit ido-ubiquitous ido-vertical-mode
      yasnippet projectile multiple-cursors ace-jump-mode

      ;; highlighting
      idle-highlight-mode highlight-symbol highlight-numbers highlight-quoted

      ;; org-mode
      org htmlize gnuplot-mode gnuplot

      ;; config
      ssh-config-mode

      ;; flycheck
      flycheck flycheck-tip

      ;; clojure
      clojure-mode clojure-mode-extra-font-locking cider paredit paren-face

      ;; ruby
      ;; ruby-mode ruby-test-mode inf-ruby puppet-mode rbenv chruby

      ;; emacs-lisp
      elisp-slime-nav paredit

      ;; markup language
      markdown-mode markdown-mode+ yaml-mode

      ;; git
      magit git-gutter ;;git-timemachine magit-gh-pulls with-editor git-annex
      ))

  (dolist (pack smd/install-packages)
    (unless (package-installed-p pack)
      (package-install pack)))

  ;; Load use-package, used for loading packages everywhere else
  (require 'use-package)
  ;; Set to t to debug package loading
  (setq use-package-verbose nil)
#+END_SRC

** Using org-mode to keep track of things
*** Basic configuration
    I like a `docs/` directory in $HOME, so this is where I keep my
    org files. I'm trying out keeping notes in a single file.

    #+BEGIN_SRC emacs-lisp
      (setq org-directory "~/docs/org")
      (setq org-default-notes-file (concat org-directory "/notes.org"))
    #+END_SRC

    I would like to be able to keep an agenda and get to it quickly.

    #+BEGIN_SRC emacs-lisp
      (define-key global-map "\C-ca" 'org-agenda)
    #+END_SRC

    I like a few different agenda files

    #+BEGIN_SRC emacs-lisp
      (setq org-agenda-files
            '("~/docs/org/personal/meetups.org" "~/docs/org/tasks.org" "~/docs/org/work/lfo.org"))
    #+END_SRC

    I would like to automatically count words - helps for writing

    #+begin_src emacs-lisp :tangle yes
      (add-hook 'org-mode-hook 'wc-mode)
    #+end_src

    Keep timestamps in a drawer

    #+BEGIN_SRC emacs-lisp
      (setq org-clock-into-drawer t)
    #+END_SRC

    Configure how Org does time clocking on task's state changes, from
    http://sachachua.com/blog/2007/12/clocking-time-with-emacs-org/

    #+BEGIN_SRC emacs-lisp
      (eval-after-load 'org
        '(progn
           (defun smd/org-clock-in-if-starting ()
             "Clock in when the task is marked STARTED."
             (when (and (string= org-state "STARTED")
                        (not (string= org-last-state org-state)))
               (org-clock-in)))
           (add-hook 'org-after-todo-state-change-hook
                     'smd/org-clock-in-if-starting)
           (defadvice org-clock-in (after smd activate)
             "Set this task's status to 'STARTED'."
             (org-todo "STARTED"))
           (defun smd/org-clock-out-if-waiting ()
             "Clock out when the task is marked WAITING."
             (when (and (string= org-state "WAITING")
                        (equal (marker-buffer org-clock-marker) (current-buffer))
                        (< (point) org-clock-marker)
                        (> (save-excursion (outline-next-heading) (point))
                           org-clock-marker)
                        (not (string= org-last-state org-state)))
               (org-clock-out)))
           (add-hook 'org-after-todo-state-change-hook
                     'smd/org-clock-out-if-waiting)))
    #+END_SRC

*** SOMEDAY GTD ideas
Use a GTD-style set of states for tasks
#+BEGIN_SRC emacs-lisp
      (setq org-todo-keywords
        '((sequence "TODO" "STARTED" "WAITING" "SOMEDAY" "DONE")))
#+END_SRC
*** INPROGRESS Capturing notes quickly
    `C-c r` is how I'll get to "remembering" a thing.

    #+BEGIN_SRC emacs-lisp
      (define-key global-map "\C-cr" 'org-capture)
    #+END_SRC

    Org is good at helping me keep track of things that I don't want to forget.
    For example, I make journal entries that are personal, lists of tasks for
    various projects, and keep a log of my bike rides.

    TODO: I would like my ride log to go under the training log heading.

    #+BEGIN_SRC emacs-lisp
      (setq org-capture-templates
            '(
              ("t" "TODO item" entry
               (file+headline "~/docs/org/tasks.org" "new tasks")
               "* TODO %?")
              ("j" "Journal entry" entry
               (file+datetree "~/docs/org/personal/journal.org")
               "* %?")
              ("r" "A Bicycle Ride" entry
               (file+datetree  "~/docs/org/personal/bikes.org")
               "* %U\n  %?")
              ("m" "Meetup note" entry
               (file+headline  "~/docs/org/personal/meetups.org" "Tasks")
               "* %U\n  %?")
              ))
    #+END_SRC

*** INPROGRESS Literate Progragramming
I like writing in Org, so I'm testing the waters of writing my code in a
literate style. It begins as a narrative where we use the structural aspects to
represent namespaces. If we can draw a good outline of our code, then maybe we
can keep the complexity down to a minimum.

I'll use some tricks when I write my spells, though. We'll use Cider to evaluate
Clojure code within an Org code-block

#+BEGIN_SRC emacs-lisp
  (setq org-babel-clojure-backend 'cider)
  (require 'ob-clojure)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sh . t)
     (clojure . t)))
#+END_SRC

I would like to be able to insert code snippets, so let's try yasnippet

#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC

** Basics and settings used everywhere

   Mostly settings that don't fit in elsewhere, so they end up here. However,
   this does include settings that aren't part of packages and need to configure
   Emacs' built-in packages.

*** General settings
Turn on debugging (it will be turned off at the end). In case something happens
during loading that breaks something, it's nice to have debug information.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
#+END_SRC

Don't show the startup message.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Don't beep.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda()))
#+END_SRC

Always indent, per mode, on newline.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

Dakrone says: "Always, *always*, prefer UTF-8, anything else is insanity."

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC

Turn on syntax highlighting for all buffers:

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

Don't warn me about large files unless they're at least 25mb:

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 25 1024 1024))
#+END_SRC

If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp
(transient-mark-mode t)
#+END_SRC

Turn off all kinds of modes, I don't need the menu bar, or the tool bar:

#+BEGIN_SRC emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
#+END_SRC

Why would you not want to know lines/columns in your mode-line?

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Ignore case when using completion for file names:

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Don't make me type "yes" at a prompt

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Set up the fill-column to 80 characters and set tab width to 2

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(setq-default default-tab-width 2)
(setq-default indent-tabs-mode nil)
#+END_SRC

It's okay to refer to a file by a symlink:

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename nil)
#+END_SRC

Require a newline at the end of files:

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Uniquify buffers, using angle brackets, so you get =foo= and
=foo<2>=:

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

Single space still ends a sentence:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Always turn on whitespace mode

#+BEGIN_SRC emacs-lisp
(whitespace-mode t)
#+END_SRC

Indicate trailing empty lines in the GUI, but get rid of them on save. That's
sneaky.

#+BEGIN_SRC emacs-lisp
(set-default 'indicate-empty-lines t)
(setq show-trailing-whitespace t)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Bury the =*scratch*= buffer, never kill it:

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

Prettify all the symbols, if available (an Emacs 24.4 feature):

#+BEGIN_SRC emacs-lisp
(when (boundp 'global-prettify-symbols-mode)
  (add-hook 'emacs-lisp-mode-hook
            (lambda ()
              (push '("lambda" . ?λ) prettify-symbols-alist)))
  (add-hook 'clojure-mode-hook
            (lambda ()
              (push '("fn" . ?ƒ) prettify-symbols-alist)))
  (global-prettify-symbols-mode +1))
#+END_SRC

*** Setup Ido Mode for fancy customizations

Use ido-mode everywhere! See https://www.masteringemacs.org/article/introduction-to-ido-mode

#+BEGIN_SRC emacs-lisp
(ido-mode 1)
(setq ido-enable-flex-matching t)
(setq ido-create-new-buffer 'always)
(setq ido-everywhere t)
#+END_SRC

*** saveplace
Navigates back to where you were editing a file next time you open it

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :init
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC

** Programming language-specific configuration

   Configuration options for language-specific packages live here.

*** General prog-mode hooks

    Some general settings that should apply to all programming modes, turning
    on subword mode and idle-highlight-mode:

#+BEGIN_SRC emacs-lisp
  (use-package idle-highlight-mode
    :init
    (progn
      (defun smd/idle-highlight-hook ()
        (interactive)
        (when (fboundp 'idle-highlight-mode)
          (idle-highlight-mode t))
        (setq show-trailing-whitespace t)
        (subword-mode t))

      (add-hook 'prog-mode-hook #'smd/idle-highlight-hook)))
#+END_SRC

    In programming modes, make sure things like FIXME and TODO are
    highlighted so they stand out:

#+BEGIN_SRC emacs-lisp
(defun smd/add-watchwords ()
  "Highlight FIXME, TODO, and NOCOMMIT in code"
  (font-lock-add-keywords
   nil '(("\\<\\(FIXME\\|TODO\\|NOCOMMIT\\)\\>"
          1 '((:foreground "#d7a3ad") (:weight bold)) t))))

(add-hook 'prog-mode-hook 'smd/add-watchwords)
#+END_SRC

    Display parentheses nicely

#+BEGIN_SRC emacs-lisp
  (require 'paren)
  (set-face-background 'show-paren-match "red")
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

*** Paredit

   Paredit for all the lisps.

#+BEGIN_SRC emacs-lisp
(use-package paredit
  :diminish "()"
  :config
  (progn
    (define-key paredit-mode-map (kbd "M-)") 'paredit-forward-slurp-sexp)
    (define-key paredit-mode-map (kbd "C-(") 'paredit-forward-barf-sexp)
    (define-key paredit-mode-map (kbd "C-)") 'paredit-forward-slurp-sexp)
    (define-key paredit-mode-map (kbd ")") 'paredit-close-parenthesis)))
#+END_SRC
*** Clojure

- eldoc prints the argument list for a function as it is being typed.

- subword allows you to move between word boundaries (e.g., CapitalizedSubWords)
  in a nomenclature.

- clj-refactor is good.
#+BEGIN_SRC emacs-lisp
  (defun smd/clojure-things-hook ()
    "Set up clojure-y things"
    (eldoc-mode 1)

    (subword-mode t)

    (clj-refactor-mode t)
    (cljr-add-keybindings-with-prefix "C-c C-m")

    ;; (auto-complete-mode t)
    ;; (rainbow-delimiters-mode t)

    (paredit-mode 1)
    ;; NOTE: These are possibly wonky settings...
    (define-key paredit-mode-map (kbd "M-[") nil)
    (define-key paredit-mode-map (kbd "<C-right>") 'paredit-forward-slurp-sexp))

  (use-package clojure-mode
    :config
    (progn (add-hook 'clojure-mode-hook 'smd/clojure-things-hook)))
#+END_SRC

    Let's define a couple of helper functions for setting up the cider and
    ac-nrepl packages:

#+BEGIN_SRC emacs-lisp
(defun smd/setup-cider ()
  (lambda ()
    (setq cider-history-file "~/.nrepl-history"
          cider-hide-special-buffers t
          cider-repl-history-size 10000
          cider-prefer-local-resources t
          cider-popup-stacktraces-in-repl t)
    (paredit-mode 1)
    (eldoc-mode 1)))
#+END_SRC

    And then finally use them if cider and ac-nrepl packages are available:

#+BEGIN_SRC emacs-lisp
(use-package cider
  :init
  (progn
    (add-hook 'cider-mode-hook 'smd/setup-cider)
    (add-hook 'cider-repl-mode-hook 'smd/setup-cider)
    (add-hook 'cider-mode-hook 'smd/clojure-things-hook)
    (add-hook 'cider-repl-mode-hook 'smd/clojure-things-hook)))
#+END_SRC

    Here we test out inserting clojure evaluations into the current buffer

#+BEGIN_SRC emacs-lisp
  (defun jj-cider-eval-and-get-value (v)
    (let ((nrepl-sync-request-timeout nil))
    (nrepl-dict-get (nrepl-sync-request:eval v) "value")))

  (defun jj-cider-interactive-eval-print (form)
    "Evaluate the given FORM and print value in current buffer."
    (let ((buffer (current-buffer)))
      (cider-eval form
                  (cider-eval-print-handler buffer)
                  (cider-current-ns))))

  (defun jj-cider-eval-last-sexp-and-append ()
    "Evaluate the expression preceding point and append result."
    (interactive)
    (let ((last-sexp (cider-last-sexp)))
      ;; we have to be sure the evaluation won't result in an error
      (jj-cider-eval-and-get-value last-sexp)
      (with-current-buffer (current-buffer)
        (insert ";;=>\n"))
      (jj-cider-interactive-eval-print last-sexp)))


  (defun jj-cider-format-with-out-str-pprint-eval (form)
    "Return a string of Clojure code that will return pretty-printed FORM."
    (format "(clojure.core/let [x %s] (with-out-str (clojure.pprint/pprint x)))"
        form))


  (defun jj-cider-eval-last-sexp-and-pprint-append ()
    "Evaluate the expression preceding point and append pretty-printed result."
    (interactive)
    (let ((last-sexp (cider-last-sexp)))
      ;; we have to be sure the evaluation won't result in an error
      (with-current-buffer (current-buffer)
        (insert (concat "\n;;=>\n"
                        (read
                          (jj-cider-eval-and-get-value
                           (jj-cider-format-with-out-str-pprint-eval last-sexp))))))))

  (defun jj-cider-eval-last-sexp ()
    "Evaluate the expression preceding point and show pretty-printed result in minibuffer"
    (interactive)
    (let ((last-sexp (cider-last-sexp)))
      (message (read
                (jj-cider-eval-and-get-value
                 (jj-cider-format-with-out-str-pprint-eval last-sexp))))))

  (defun jj-cider-move-forward-and-eval ()
    (interactive)
    (paredit-forward)
    (jj-cider-eval-last-sexp))
#+END_SRC

Write backup files to own directory

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist
      `(("." . ,(expand-file-name
                 (concat user-emacs-directory "backups")))))
#+END_SRC

Make backups of files, even when they're in version control
#+BEGIN_SRC emacs-lisp
(setq vc-make-backup-files t)
#+END_SRC

** Projectile

Always use Projectile because turning it on for specific things is annoying.

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Snippets

Yasnippet can be setup with

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-=") 'yas-insert-snippet)

  ;; (setq yas-snippet-dirs
  ;;       '("~/.emacs.d/snippets"                 ;; personal snippets
  ;;         "/path/to/some/collection/"           ;; foo-mode and bar-mode snippet collection
  ;;         "/path/to/yasnippet/yasmate/snippets" ;; the yasmate collection
  ;;         "/path/to/yasnippet/snippets"         ;; the default collection
  ;;         ))

  (yas-global-mode 1) ;; or M-x yas-reload-all if you've started YASnippet already.
#+END_SRC

I can make a geojson snippet with this:

#+begin_src javascript
  {
      "type": "Feature",
      "properties": {
          "name": "Janet's Cabin",
          "amenity": "Gas, electric lights, multiple rooms, ",
          "comments": "This is the first hut the Mo and I visited. It was a learning experience."
      },
      "geometry": {
          "type": "Point",
          "coordinates": [-104.99404, 39.75621]
      }
  }
#+end_src

** Misc editing functions

Some IDEs (like RubyMine and IntelliJ) let you put a newline above the point.
This is a shot at getting that behavior in Emacs.

#+BEGIN_SRC emacs-lisp
  (defun smd/smart-open-line-above ()
    "Insert an empty line above the current line.
    Position the cursor at it's beginning, according to the current mode."
    (interactive)
    (move-beginning-of-line nil)
    (newline-and-indent)
    (forward-line -1)
    (indent-according-to-mode))

  (global-set-key [(control shift return)] 'smd/smart-open-line-above)
#+END_SRC

* Finalizers
Turn off debugging, now that initialization has ended

#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
#+END_SRC
