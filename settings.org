#+TITLE:   Sean's Emacs Configuration
#+AUTHOR:  Sean Duckett
#+EMAIL:   sean@hungryllama.net
#+LANGUAGE: en
#+PROPERTY: header-args :tangle yes
#+HTML_HEAD: <link rel="stylesheet" href="http://dakrone.github.io/org.css" type="text/css" />
#+EXPORT_SELECT_TAGS: export
#+EXPORT_EXCLUDE_TAGS: noexport
#+OPTIONS: H:4 num:nil toc:t \n:nil @:t ::t |:t ^:{} -:t f:t *:t
#+OPTIONS: skip:nil d:(HIDE) tags:not-in-toc
#+TODO: SOMEDAY(s) TODO(t) INPROGRESS(i) WAITING(w@/!) NEEDSREVIEW(n@/!) | DONE(d)
#+TODO: WAITING(w@/!) HOLD(h@/!) | CANCELLED(c@/!)
#+TAGS: export(e) noexport(n)
#+STARTUP: align fold nodlcheck lognotestate content

* Introduction

This is an experiment to see how keeping a literate configuration for Emacs
feels; how does it affect my thinking of the system as a whole? There might be
things that don't work, broken code, and descriptions that are hard to follow.
This file was last exported: {{{time(%Y-%m-%d %H:%M)}}}

* Getting Started
To get started, have a look at your `~/.emacs.d/init.el`. If you've done any
Emacs customizations there (font / color tweaks, etc), move them to a file
(perhaps `~/.emacs.d/custom-additions.el`) that you can load them after we do
some setup.

Next, put the following in `~/.emacs.d/init.el`:

#+BEGIN_SRC elisp
  ;; keep customized settings in their own file
  (setq custom-file "~/.emacs.d/custom.el")
  (when (file-exists-p custom-file)
    (load custom-file))

  ;; translate the literate configuration and load it.
  (require 'org)

  (org-babel-load-file
   (expand-file-name "settings.org"
                     user-emacs-directory))
#+END_SRC

This gives use the ability to write a literate org-mode file using [[http://orgmode.org/worg/org-contrib/babel/intro.html][Babel]]; this
is simply an org file with code blocks interspersed. When we load this file with
`org-babel-load-file`, it is transformed into Emacs Lisp by stripping the text
away from the code blocks. This is base which the rest of my configuration is
built upon.

* Emacs Package Management
The first thing to do is setup package managment with a few of our favorite
collections.

#+BEGIN_SRC emacs-lisp
  (require 'package)

  (when (< emacs-major-version 24)
    (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/")))

  (add-to-list 'package-archives '("marmalade" . "http://marmalade-repo.org/packages/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
  (add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
#+END_SRC

Some of the packages I use get released with breaking changes from time to time,
so it seems prudent to only use the versions hosted by the "stable"
repositories.

#+begin_src emacs-lisp :tangle yes
  (add-to-list 'package-pinned-packages '(cider . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(clj-refactor . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(magit . "melpa-stable") t)
  (add-to-list 'package-pinned-packages '(ob-http . "melpa-stable") t)

  (package-initialize)
#+end_src

#+begin_src emacs-lisp :tangle yes
    (defvar smd/packages-to-install
      '(use-package gist popup company smex ido-vertical-mode
         ido-ubiquitous yasnippet projectile multiple-cursors ace-jump-mode
         idle-highlight-mode highlight-symbol highlight-numbers highlight-quoted
         org htmlize gnuplot-mode gnuplot wc-mode
         ;; ssh-config-mode
         flycheck flycheck-tip
         clojure-mode clojure-mode-extra-font-locking cider paredit paren-face
         ruby-mode ruby-test-mode inf-ruby rbenv elisp-slime-nav markdown-mode
         markdown-mode+ yaml-mode magit git-gutter git-timemachine magit-gh-pulls
         git-annex helm helm-descbinds helm-ag helm-projectile helm-swoop  helm-gtags
         helm-ls-git helm-flycheck helm-flyspell helm-flx ob-http))

    (dolist (package smd/packages-to-install)
      (unless (package-installed-p package)
        (package-install package)))
#+end_src

Load [[https://github.com/jwiegley/use-package][use-package]] for loading packages everywhere else. If you set
`use-package-verbose` to `t`, it will debug package loading. What do you think
of this? Does it make things simpler?

#+begin_src emacs-lisp :tangle yes
  (require 'use-package)
  (setq use-package-verbose nil)
#+end_src

* Configuration
* Using org-mode to keep track of things
** Babel configuration
#+begin_src emacs-lisp :tangle yes
(org-babel-do-load-languages
 'org-babel-load-languages
 '((emacs-lisp . t)
   (clojure . t)
   (sh . t)
   (http . t)))

;; Specify the Clojure back-end we want to use in Org-mode.
;; I personally use Cider, but one could specify Slime
(setq org-babel-clojure-backend 'cider)

;; Let's have pretty source code blocks
;; (setq org-edit-src-content-indentation 0
;;       org-src-tab-acts-natively t
;;       org-src-fontify-natively t
;;       org-confirm-babel-evaluate nil
;;       org-support-shift-select 'always)

#+end_src
** Basic configuration
I like a `docs/` directory in $HOME, so this is where I keep my org files. I'm
trying out keeping notes in a single file.

#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/docs/org")
  (setq org-default-notes-file (concat org-directory "/notes.org"))
#+END_SRC

I would like to be able to keep an agenda and get to it quickly.

#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files '("~/docs/org/tasks.org"))
  (define-key global-map "\C-ca" 'org-agenda)
#+END_SRC

We'll mark tasks with a GTD-style set of states.

#+BEGIN_SRC emacs-lisp
  (setq org-todo-keywords
    '((sequence "TODO" "STARTED" "WAITING" "SOMEDAY" "DONE")))
#+END_SRC

Keep timestamps in a drawer.

#+BEGIN_SRC emacs-lisp
  (setq org-clock-into-drawer t)
#+END_SRC

[[http://sachachua.com/blog/2007/12/clocking-time-with-emacs-org/][Configure how Org does time clocking on task's state changes]]

#+BEGIN_SRC emacs-lisp
  (eval-after-load 'org
    '(progn
       (defun smd/org-clock-in-if-starting ()
         "Clock in when the task is marked STARTED."
         (when (and (string= org-state "STARTED")
                    (not (string= org-last-state org-state)))
           (org-clock-in)))
       (add-hook 'org-after-todo-state-change-hook
                 'smd/org-clock-in-if-starting)
       (defadvice org-clock-in (after smd activate)
         "Set this task's status to 'STARTED'."
         (org-todo "STARTED"))
       (defun smd/org-clock-out-if-waiting ()
         "Clock out when the task is marked WAITING."
         (when (and (string= org-state "WAITING")
                    (equal (marker-buffer org-clock-marker) (current-buffer))
                    (< (point) org-clock-marker)
                    (> (save-excursion (outline-next-heading) (point))
                       org-clock-marker)
                    (not (string= org-last-state org-state)))
           (org-clock-out)))
       (add-hook 'org-after-todo-state-change-hook
                 'smd/org-clock-out-if-waiting)))
#+END_SRC

Helm is a useful thing for doing stuff:


#+BEGIN_SRC emacs-lisp
  (use-package helm-flx
               :init (helm-flx-mode +1))

  (use-package helm-config
               :demand t
               :bind
               (("C-M-z" . helm-resume)
                ("C-x C-f" . helm-find-files)
                ("C-x C-r" . helm-mini)
                ("C-x M-o" . helm-occur)
                ("M-y" . helm-show-kill-ring)
                ("C-h a" . helm-apropos)
                ("C-h m" . helm-man-woman)
                ("C-h SPC" . helm-all-mark-rings)
                ("M-g >" . helm-ag-this-file)
                ("M-g ," . helm-ag-pop-stack)
                ("M-g ." . helm-do-grep)
                ("C-x C-i" . helm-semantic-or-imenu)
                ("M-x" . helm-M-x)
                ("C-x C-b" . helm-buffers-list)
                ("C-x C-r" . helm-mini)
                ("C-x b" . helm-mini)
                ("C-h t" . helm-world-time))
               :config
               (use-package
                helm-files
                :config (setq helm-ff-file-compressed-list
                              '("gz" "bz2" "zip" "tgz")))
               (use-package helm-commands)
               (use-package helm-buffers)
               (use-package helm-mode
                            :diminish helm-mode
                            :init (helm-mode 1))
               (use-package helm-ls-git
                            :bind ("C-x C-d" . helm-browse-project))
               (use-package helm-grep
                            :config
                            (progn
                              (define-key helm-grep-mode-map (kbd "<return>")  'helm-grep-mode-jump-other-window)
                              (define-key helm-grep-mode-map (kbd "n")  'helm-grep-mode-jump-other-window-forward)
                              (define-key helm-grep-mode-map (kbd "p")  'helm-grep-mode-jump-other-window-backward)))
               (use-package helm-man)
               (use-package helm-misc)
               (use-package helm-aliases)
               (use-package helm-elisp)
               (use-package helm-imenu)
               (use-package helm-semantic)
               (use-package helm-ring)
               (use-package helm-bookmark
                            :bind ("C-x M-b" . helm-bookmarks))
               (use-package helm-projectile
                            :bind (("C-x f" . helm-projectile)
                                   ("C-c p f" . helm-projectile-find-file)
                                   ("C-c p s" . helm-projectile-switch-project)))

               (global-set-key (kbd "C-c h") 'helm-command-prefix)
               (global-unset-key (kbd "C-x c"))

               (setq helm-idle-delay 0.01
                     helm-exit-idle-delay 0.1
                     helm-input-idle-delay 0.01
                     ;; truncate long lines in helm completion
                     helm-truncate-lines t
                     ;; may be overridden if 'ggrep' is in path (see below)
                     helm-grep-default-command
                     "grep -a -d skip %e -n%cH -e %p %f"
                     helm-grep-default-recurse-command
                     "grep -a -d recurse %e -n%cH -e %p %f"
                     ;; do not display invisible candidates
                     helm-quick-update t
                     ;; be idle for this many seconds, before updating in delayed sources.
                     helm-idle-delay 0.01
                     ;; use 40% of the window for things
                     ;; helm-autoresize-max-height 40
                     ;; helm-autoresize-min-height 40
                     ;; wider buffer name in helm-buffers-list
                     helm-buffer-max-length 25 ;; default is 20
                     ;; be idle for this many seconds, before updating candidate buffer
                     helm-input-idle-delay 0.01
                     ;; open helm buffer in another window
                     helm-split-window-default-side 'other
                     ;; open helm buffer inside current window, don't occupy whole other window
                     helm-split-window-in-side-p t
                     ;; limit the number of displayed canidates
                     helm-candidate-number-limit 200
                     ;; don't use recentf stuff in helm-ff, I use C-x C-r for this
                     helm-ff-file-name-history-use-recentf nil
                     ;; move to end or beginning of source when reaching top or bottom
                     ;; of source
                     helm-move-to-line-cycle-in-source t
                     ;; don't display the header line
                     helm-display-header-line nil
                     ;; fuzzy matching
                     helm-recentf-fuzzy-match t
                     helm-locate-fuzzy-match nil ;; locate fuzzy is worthless
                     helm-M-x-fuzzy-match t
                     helm-buffers-fuzzy-matching t
                     helm-semantic-fuzzy-match t
                     helm-apropos-fuzzy-match t
                     helm-imenu-fuzzy-match t
                     helm-lisp-fuzzy-completion t
                     helm-completion-in-region-fuzzy-match t
                     ;; Here are the things helm-mini shows, I add `helm-source-bookmarks'
                     ;; here to the regular default list
                     helm-mini-default-sources '(helm-source-buffers-list
                                                 helm-source-recentf
                                                 helm-source-bookmarks
                                                 helm-source-buffer-not-found))

               (define-key helm-map (kbd "<tab>") 'helm-execute-persistent-action) ; rebind tab to do persistent action
               (define-key helm-map (kbd "C-i") 'helm-execute-persistent-action) ; make TAB works in terminal
               (define-key helm-map (kbd "C-z")  'helm-select-action) ; list actions using C-z

               (define-key helm-map (kbd "C-p")   'helm-previous-line)
               (define-key helm-map (kbd "C-n")   'helm-next-line)
               (define-key helm-map (kbd "C-M-n") 'helm-next-source)
               (define-key helm-map (kbd "C-M-p") 'helm-previous-source)
               (define-key helm-map (kbd "M-N")   'helm-next-source)
               (define-key helm-map (kbd "M-P")   'helm-previous-source)
               ;; The normal binding is C-c h M-g s which is insane
               (global-set-key (kbd "C-c h g")    'helm-do-grep)
               (global-set-key (kbd "C-c h a")    'helm-do-ag)

               (when (executable-find "curl")
                 (setq helm-google-suggest-use-curl-p t))

               ;; helm-mini instead of recentf
               (define-key 'help-command (kbd "C-f") 'helm-apropos)
               (define-key 'help-command (kbd "r") 'helm-info-emacs))
#+END_SRC

** Capturing notes quickly
=C-c r= is how I'll capture a thought.

#+BEGIN_SRC emacs-lisp
  (define-key global-map "\C-cr" 'org-capture)

  (setq org-capture-templates
        '(("t" "TODO item" entry
           (file+headline "~/docs/org/tasks.org" "Tasks")
           "* TODO %?")
          ("s" "Standup" entry
           (file+datetree "~/docs/dw.org")
           "* %?")
          ("j" "Journal entry" entry
           (file+datetree "~/docs/org/personal/journal.org")
           "* %?")
          ("m" "Meetup note" entry
           (file+headline  "~/docs/org/personal/meetups.org" "Tasks")
           "* %U\n  %?")))
#+END_SRC

** INPROGRESS Literate Progragramming
I like writing in Org, so I'm testing the waters of writing my code in a
literate style. It begins as a narrative where we use the structural aspects to
represent namespaces. If we can draw a good outline of our code, then maybe we
can keep the complexity down to a minimum.

I'll use some tricks when I write my spells, though. We'll use Cider to evaluate
Clojure code within an Org code-block

#+BEGIN_SRC emacs-lisp
  (setq org-babel-clojure-backend 'cider)
  (require 'ob-clojure)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((sh . t)
     (clojure . t)))
#+END_SRC

I would like to be able to insert code snippets, so let's try yasnippet

#+BEGIN_SRC emacs-lisp
(require 'yasnippet)
(yas-global-mode 1)
#+END_SRC

* Basics and settings used everywhere
Mostly settings that don't fit in elsewhere, so they end up here. However, this
does include settings that aren't part of packages and need to configure Emacs'
built-in packages.

** General settings
Turn on debugging (it will be turned off at the end). In case something happens
during loading that breaks something, it's nice to have debug information.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error t)
#+END_SRC

Don't show the startup message.

#+BEGIN_SRC emacs-lisp
(setq inhibit-startup-message t
      inhibit-startup-echo-area-message t)
#+END_SRC

Don't beep.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function (lambda()))
#+END_SRC

Always indent, per mode, on newline.

#+BEGIN_SRC emacs-lisp
(define-key global-map (kbd "RET") 'newline-and-indent)
#+END_SRC

Dakrone says: "Always, *always*, prefer UTF-8, anything else is insanity."

#+BEGIN_SRC emacs-lisp
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-language-environment "UTF-8")
(prefer-coding-system 'utf-8)
#+END_SRC

Turn on syntax highlighting for all buffers:

#+BEGIN_SRC emacs-lisp
(global-font-lock-mode t)
#+END_SRC

Don't warn me about large files unless they're at least 25mb:

#+BEGIN_SRC emacs-lisp
(setq large-file-warning-threshold (* 25 1024 1024))
#+END_SRC

If you change buffer, or focus, disable the current buffer's mark:

#+BEGIN_SRC emacs-lisp
(transient-mark-mode t)
#+END_SRC

Turn off all kinds of modes, I don't need the menu bar, or the tool bar:

#+BEGIN_SRC emacs-lisp
(when (functionp 'menu-bar-mode)
  (menu-bar-mode -1))
(when (functionp 'set-scroll-bar-mode)
  (set-scroll-bar-mode 'nil))
(when (functionp 'mouse-wheel-mode)
  (mouse-wheel-mode -1))
(when (functionp 'tooltip-mode)
  (tooltip-mode -1))
(when (functionp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (functionp 'blink-cursor-mode)
  (blink-cursor-mode -1))
#+END_SRC

Show line & column position in your mode-line

#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Ignore case when using completion for file names

#+BEGIN_SRC emacs-lisp
(setq read-file-name-completion-ignore-case t)
#+END_SRC

Don't make me type "yes" at a prompt

#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Set up the fill-column to 80 characters and set tab width to 2

#+BEGIN_SRC emacs-lisp
(setq-default fill-column 80)
(setq-default default-tab-width 2)
(setq-default indent-tabs-mode nil)
#+END_SRC

It's okay to refer to a file by a symlink:

#+BEGIN_SRC emacs-lisp
(setq-default find-file-visit-truename nil)
#+END_SRC

Require a newline at the end of files:

#+BEGIN_SRC emacs-lisp
(setq require-final-newline t)
#+END_SRC

Uniquify buffers, using angle brackets, so you get =foo= and
=foo<2>=:

#+BEGIN_SRC emacs-lisp
(use-package uniquify
  :config
  (setq uniquify-buffer-name-style 'post-forward-angle-brackets))
#+END_SRC

Single space still ends a sentence:

#+BEGIN_SRC emacs-lisp
(setq sentence-end-double-space nil)
#+END_SRC

Always turn on whitespace mode

#+BEGIN_SRC emacs-lisp
(whitespace-mode t)
#+END_SRC

Indicate trailing empty lines in the GUI, but get rid of them on save. That's
sneaky.

#+BEGIN_SRC emacs-lisp
(set-default 'indicate-empty-lines t)
(setq show-trailing-whitespace t)
(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC

Bury the =*scratch*= buffer, never kill it:

#+BEGIN_SRC emacs-lisp
(defadvice kill-buffer (around kill-buffer-around-advice activate)
  (let ((buffer-to-kill (ad-get-arg 0)))
    (if (equal buffer-to-kill "*scratch*")
        (bury-buffer)
      ad-do-it)))
#+END_SRC

Let's bind some things to move around buffers easily

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-c y") 'bury-buffer)
  ;;(global-set-key (kbd "C-c r") 'revert-buffer)
#+END_SRC

Prettify all the symbols, if available (an Emacs 24.4 feature):

#+BEGIN_SRC emacs-lisp
  (defvar smd/clojure-prettify-alist '())

  (add-to-list 'smd/clojure-prettify-alist '(">=" . ?≥))
  (add-to-list 'smd/clojure-prettify-alist '("<=" . ?≤))
  (add-to-list 'smd/clojure-prettify-alist '("fn" . ?ƒ))
  (add-to-list 'smd/clojure-prettify-alist '("lambda" . ?λ))

  (eval-after-load 'clojure-mode
    '(setq clojure--prettify-symbols-alist
           (append smd/clojure-prettify-alist
                   clojure--prettify-symbols-alist)))
#+END_SRC

** Getting Emacs to play with Tmux in a terminal

Oh, this is somewhat hellish, but there are a few things going on here:

1. You must have the TERM environment setup correctly, to "screen-256color" or so when in Tmux
2. You must have "xterm-keys on" in your Tmux config
3. You "must" do some funky remapping of keys, according to the internet....I hope there's a better way.

#+BEGIN_SRC emacs-lisp
  ;; This is from: https://wiki.archlinux.org/index.php/Emacs#Shift_.2B_Arrow_keys_not_working_in_emacs_within_tmux

  (if (getenv "TMUX")
      (progn
        (let ((x 2) (tkey ""))
          (while (<= x 8)
            ;; shift
            (if (= x 2)
                (setq tkey "S-"))
            ;; alt
            (if (= x 3)
                (setq tkey "M-"))
            ;; alt + shift
            (if (= x 4)
                (setq tkey "M-S-"))
            ;; ctrl
            (if (= x 5)
                (setq tkey "C-"))
            ;; ctrl + shift
            (if (= x 6)
                (setq tkey "C-S-"))
            ;; ctrl + alt
            (if (= x 7)
                (setq tkey "C-M-"))
            ;; ctrl + alt + shift
            (if (= x 8)
                (setq tkey "C-M-S-"))

            ;; arrows
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d A" x)) (kbd (format "%s<up>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d B" x)) (kbd (format "%s<down>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d C" x)) (kbd (format "%s<right>" tkey)))
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d D" x)) (kbd (format "%s<left>" tkey)))
            ;; home
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d H" x)) (kbd (format "%s<home>" tkey)))
            ;; end
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d F" x)) (kbd (format "%s<end>" tkey)))
            ;; page up
            (define-key key-translation-map (kbd (format "M-[ 5 ; %d ~" x)) (kbd (format "%s<prior>" tkey)))
            ;; page down
            (define-key key-translation-map (kbd (format "M-[ 6 ; %d ~" x)) (kbd (format "%s<next>" tkey)))
            ;; insert
            (define-key key-translation-map (kbd (format "M-[ 2 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; delete
            (define-key key-translation-map (kbd (format "M-[ 3 ; %d ~" x)) (kbd (format "%s<delete>" tkey)))
            ;; f1
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d P" x)) (kbd (format "%s<f1>" tkey)))
            ;; f2
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d Q" x)) (kbd (format "%s<f2>" tkey)))
            ;; f3
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d R" x)) (kbd (format "%s<f3>" tkey)))
            ;; f4
            (define-key key-translation-map (kbd (format "M-[ 1 ; %d S" x)) (kbd (format "%s<f4>" tkey)))
            ;; f5
            (define-key key-translation-map (kbd (format "M-[ 15 ; %d ~" x)) (kbd (format "%s<f5>" tkey)))
            ;; f6
            (define-key key-translation-map (kbd (format "M-[ 17 ; %d ~" x)) (kbd (format "%s<f6>" tkey)))
            ;; f7
            (define-key key-translation-map (kbd (format "M-[ 18 ; %d ~" x)) (kbd (format "%s<f7>" tkey)))
            ;; f8
            (define-key key-translation-map (kbd (format "M-[ 19 ; %d ~" x)) (kbd (format "%s<f8>" tkey)))
            ;; f9
            (define-key key-translation-map (kbd (format "M-[ 20 ; %d ~" x)) (kbd (format "%s<f9>" tkey)))
            ;; f10
            (define-key key-translation-map (kbd (format "M-[ 21 ; %d ~" x)) (kbd (format "%s<f10>" tkey)))
            ;; f11
            (define-key key-translation-map (kbd (format "M-[ 23 ; %d ~" x)) (kbd (format "%s<f11>" tkey)))
            ;; f12
            (define-key key-translation-map (kbd (format "M-[ 24 ; %d ~" x)) (kbd (format "%s<f12>" tkey)))
            ;; f13
            (define-key key-translation-map (kbd (format "M-[ 25 ; %d ~" x)) (kbd (format "%s<f13>" tkey)))
            ;; f14
            (define-key key-translation-map (kbd (format "M-[ 26 ; %d ~" x)) (kbd (format "%s<f14>" tkey)))
            ;; f15
            (define-key key-translation-map (kbd (format "M-[ 28 ; %d ~" x)) (kbd (format "%s<f15>" tkey)))
            ;; f16
            (define-key key-translation-map (kbd (format "M-[ 29 ; %d ~" x)) (kbd (format "%s<f16>" tkey)))
            ;; f17
            (define-key key-translation-map (kbd (format "M-[ 31 ; %d ~" x)) (kbd (format "%s<f17>" tkey)))
            ;; f18
            (define-key key-translation-map (kbd (format "M-[ 32 ; %d ~" x)) (kbd (format "%s<f18>" tkey)))
            ;; f19
            (define-key key-translation-map (kbd (format "M-[ 33 ; %d ~" x)) (kbd (format "%s<f19>" tkey)))
            ;; f20
            (define-key key-translation-map (kbd (format "M-[ 34 ; %d ~" x)) (kbd (format "%s<f20>" tkey)))

            (setq x (+ x 1))))))
#+END_SRC
** A Terminal in Emacs
Don't ask me about my shell of choice
#+begin_src emacs-lisp :tangle yes
  (setq explicit-shell-file-name "/bin/zsh")
#+end_src

How do you switch modes again, Chris?
#+begin_src emacs-lisp :tangle yes
  (add-hook 'term-mode-hook '(lambda ()
    (setq mode-line-format
      (list
       " "
       '(:eval (propertize "%b "))
       "("
       '(:eval (propertize "%m "))
       '(:eval (if (term-in-char-mode)
                   "char) [C-x C-j to switch]"
                   "line) [C-c C-k to switch]"))))))
#+end_src

** SMEX

https://github.com/nonsequitur/smex

#+BEGIN_SRC emacs-lisp
  (smex-initialize)

  (global-set-key (kbd "M-x") 'smex)
  (global-set-key (kbd "M-X") 'smex-major-mode-commands)

  ;; This is your old M-x.
  (global-set-key (kbd "C-c C-c M-x") 'execute-extended-command)
#+END_SRC

** Setup Ido Mode for fancy customizations

Use ido-mode everywhere! See https://www.masteringemacs.org/article/introduction-to-ido-mode

#+BEGIN_SRC emacs-lisp
  (require 'ido-vertical-mode)
  (require 'ido-ubiquitous)

  (ido-mode 1)
  (ido-everywhere 1)
  (ido-ubiquitous-mode 1)
  (ido-vertical-mode 1)

  (setq ido-vertical-define-keys 'C-n-and-C-p-only)
  (setq ido-enable-flex-matching t)
  (setq ido-create-new-buffer 'always)
#+END_SRC

** Saveplace
Navigates back to where you were editing a file next time you open it

#+BEGIN_SRC emacs-lisp
(use-package saveplace
  :init
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" user-emacs-directory)))
#+END_SRC

** Ace Jump Mode

From <https://github.com/winterTTr/ace-jump-mode>, we get a nice way to jump quickly around a buffer.
For a demo, watch the Emacs Rocks video: <https://www.youtube.com/watch?v=UZkpmegySnc>

#+BEGIN_SRC emacs-lisp
  (autoload
    'ace-jump-mode
    "ace-jump-mode"
    "Emacs quick move minor mode"
    t)

  ;; you can select the key you prefer to
  (define-key global-map (kbd "C-c SPC") 'ace-jump-mode)

  (autoload
    'ace-jump-mode-pop-mark
    "ace-jump-mode"
    "Ace jump back:-)"
    t)
  (eval-after-load "ace-jump-mode"
    '(ace-jump-mode-enable-mark-sync))
  (define-key global-map (kbd "C-x SPC") 'ace-jump-mode-pop-mark)


#+END_SRC

** Multiple Cursors

I like this, having learned about it in Sublime Text and the IntelliJ family of editors.

#+BEGIN_SRC emacs-lisp
  (require 'multiple-cursors)

  (global-set-key (kbd "C-c e") 'mc/edit-lines)
  (global-set-key (kbd "C-<down>") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<up>") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<down>") 'mc/mark-all-like-this)
#+END_SRC

** Version Control
I use git for most of my version control needs, and it's nice to use [[http://magit.vc/][Magit]] and
not leave Emacs pretty well. Most of the interactions comes from two functions.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch-popup)
#+END_SRC

When branching from a branch from a branch, tracking gets a little weird; don't
set it by default, but let me tell you what I want it to be. According to
[[https://github.com/tie-rack/emacs.d/blob/master/tierack.org#magit][tie-rack's settings]] around 2.1, you could do something like this

#+begin_src emacs-lisp
  ;; (setq magit-branch-arguments (remove "--track" magit-branch-arguments))
#+end_src

It looks like as of version 2.5.0 [[http://magit.vc/manual/magit/Branching.html#Branching][branching behavior]] has changed (again), and
you can use =magit-branch-spinoff= to do a similar thing:

"This command creates and checks out a new branch starting at and tracking the
current branch. That branch in turn is reset to the last commit it shares with
its upstream. If the current branch has no upstream or no unpushed commits, then
the new branch is created anyway and the previously current branch is not
touched.

This is useful to create a feature branch after work has already began on the
old branch (likely but not necessarily "master")."

** Programming Modes
(In Emacs, most programming language modes derive from prog-mode; any hooks
created for prog-mode should apply to all language modes.) Subword mode lets me
move between SegmentsOfACamelCasedThing and idle-highlight-mode will hightlight
the word under the point.

#+BEGIN_SRC emacs-lisp
  (use-package idle-highlight-mode
    :init
    (progn
      (defun smd/idle-highlight-hook ()
        (interactive)
        (when (fboundp 'idle-highlight-mode)
          (idle-highlight-mode t))
        (setq show-trailing-whitespace t)
        (subword-mode t))

      (add-hook 'prog-mode-hook #'smd/idle-highlight-hook)))
#+END_SRC

FIXME and TODO can be highlighted so they stand out

#+BEGIN_SRC emacs-lisp
  (defun smd/add-watchwords ()
    "Highlight FIXME, TODO, and NOCOMMIT in code"
    (font-lock-add-keywords
     nil '(("\\<\\(FIXME\\|TODO\\|NOCOMMIT\\)\\>"
            1 '((:foreground "#d7d7d7") (:weight bold)) t))))

  (add-hook 'prog-mode-hook 'smd/add-watchwords)
#+END_SRC

Display parentheses nicely

#+BEGIN_SRC emacs-lisp
  (require 'paren)
  (set-face-background 'show-paren-match "red")
  (add-hook 'prog-mode-hook 'show-paren-mode)
#+END_SRC

** Paredit
Paredit for all the lisps

#+BEGIN_SRC emacs-lisp
  (use-package paredit
    :diminish "()"
    :config
    (progn
      (define-key paredit-mode-map (kbd "M-)") 'paredit-forward-slurp-sexp)
      (define-key paredit-mode-map (kbd "M-(") 'paredit-forward-barf-sexp)
      (define-key paredit-mode-map (kbd ")") 'paredit-close-parenthesis)))
#+END_SRC

** Clojure

Thanks, Chris! We need to run work-tests with the profile for Datomic, Postgres, etc....

#+begin_src emacs-lisp
  (defun smd/cider-jack-in-test-profile ()
    (interactive)
    (let ((cider-lein-parameters (concat "with-profile +test "
                                         cider-lein-parameters)))
      (cider-jack-in)))

  (eval-after-load 'clojure-mode
    '(global-set-key (kbd "C-c j") #'smd/cider-jack-in-test-profile))
#+end_src

Let's define a couple of helper functions for setting up the cider and
autocomplete packages:

#+BEGIN_SRC emacs-lisp
  (defun smd/cider-figwheel-repl ()
    (interactive)
    (save-some-buffers)
    (with-current-buffer (cider-current-repl-buffer)
      (goto-char (point-max))
              (insert "(require 'figwheel-sidecar.repl-api)
               (figwheel-sidecar.repl-api/start-figwheel!) ; idempotent
               (figwheel-sidecar.repl-api/cljs-repl)")
              (cider-repl-return)))

  (defun smd/setup-cider ()
    (lambda ()
      (setq cider-history-file "~/.nrepl-history"
            cider-hide-special-buffers t
            cider-repl-history-size 10000
            cider-prefer-local-resources t
            cider-popup-stacktraces-in-repl t
            nrepl-log-messages nil
            cider-repl-history-file "src/cider-repl.log")

      (add-hook 'cider-repl-mode-hook #'company-mode)
      (add-hook 'cider-repl-mode-hook #'paredit-mode)
      (add-hook 'cider-mode-hook #'company-mode)))

  (use-package cider
    :init
    (progn
      (add-hook 'cider-mode-hook 'smd/setup-cider)
      (add-hook 'cider-repl-mode-hook 'smd/setup-cider)
      (global-set-key (kbd "M-TAB") #'company-complete)))
#+END_SRC

When writing Clojure, I would like to always use =company-mode=, =paredit=, and
a few other things. Also, Korma functions are going to get pretty nested, so
let's not indent them too much.

#+begin_src emacs-lisp :tangle yes
  (defun smd/clojure-things-hook ()
    "Set up clojure-y things"
    (company-mode 1)
    (paredit-mode 1)

    (define-clojure-indent
      (korma/select 1)
      (korma/where 1)
      (korma/insert 1)
      (korma/delete 1)
      (korma/join 1)
      (korma/update 1))

    ;; NOTE: These are possibly wonky settings...
    (define-key paredit-mode-map (kbd "M-[") nil)
    (define-key paredit-mode-map (kbd "<C-right>") 'paredit-forward-slurp-sexp)
    (global-set-key (kbd "C-c C-f") #'smd/cider-figwheel-repl))

  (use-package clojure-mode
    :config
    (progn (add-hook 'clojure-mode-hook 'smd/clojure-things-hook)))
#+end_src

Write backup files to own directory and make backups of files even when they're
in version control

#+BEGIN_SRC emacs-lisp
  (setq backup-directory-alist
        `(("." . ,(expand-file-name
                   (concat user-emacs-directory "backups")))))
  (setq vc-make-backup-files t)
#+END_SRC

** SQL things
Sometimes you need to use a relational database for some. Since I tend to use
PostgreSQL, we need to setup sql-postgres

#+begin_src emacs-lisp :tangle yes
  (setq sql-postgres-login-params
        '((user :default "smd")
          (database :default "postgres")
          (server :default "localhost")
          (port :default 5432)))
#+end_src

"PostgreSQL databases with underscores in their names trip up the prompt
specified in sql.el. I work around this with the following. Warning, this sets
the prompt globally, which is fine by me since I only ever use Postgres."
-- [[https://www.emacswiki.org/emacs/SqlMode][EmacsWiki - SqlMode]]

#+begin_src emacs-lisp :tangle yes
(add-hook 'sql-interactive-mode-hook
            (lambda ()
              (setq sql-prompt-regexp "^[_[:alpha:]]*[=][#>] ")
              (setq sql-prompt-cont-regexp "^[_[:alpha:]]*[-][#>] ")))
#+end_src
** Projectile
Always use Projectile because turning it on for specific things is annoying.

#+BEGIN_SRC emacs-lisp
  (projectile-global-mode)
#+END_SRC

** Snippets

Yasnippet can be setup with a pretty big collection of templates

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "M-=") 'yas-insert-snippet)

  ;; (setq yas-snippet-dirs
  ;;       '("~/.emacs.d/snippets"                 ;; personal snippets
  ;;         "/path/to/some/collection/"           ;; foo-mode and bar-mode snippet collection
  ;;         "/path/to/yasnippet/yasmate/snippets" ;; the yasmate collection
  ;;         "/path/to/yasnippet/snippets"         ;; the default collection
  ;;         ))

  (yas-global-mode 1) ;; or M-x yas-reload-all if you've started YASnippet already.
#+END_SRC

I can make a geojson snippet with this:

#+begin_src javascript
  {
      "type": "Feature",
      "properties": {
          "name": "Janet's Cabin",
          "amenity": "Gas, electric lights, multiple rooms, ",
          "comments": "This is the first hut the Mo and I visited. It was a learning experience."
      },
      "geometry": {
          "type": "Point",
          "coordinates": [-104.99404, 39.75621]
      }
  }
#+end_src

** Javascript
Sometimes we have to write Javascript. I guess that's that, so let's try and
make it a little more _sane_, ok?

#+begin_src emacs-lisp :tangle yes
  (setq-default js-indent-indent 2)
#+end_src
* Finally
Turn off debugging now that initialization is done.

#+BEGIN_SRC emacs-lisp
(setq debug-on-error nil)
#+END_SRC
